
package org.magnum.dataup;

import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicLong;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.collections.CollectionUtils;
import org.magnum.dataup.model.Video;
import org.magnum.dataup.model.VideoStatus;
import org.magnum.dataup.model.VideoStatus.VideoState;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.NoHandlerFoundException;

/**
 * This simple VideoController allows clients to send HTTP POST requests with
 * videos that are stored in memory using a list. Clients can send HTTP GET
 * requests to receive a JSON listing of the videos that have been sent to
 * the controller so far. Stopping the controller will cause it to lose the history of
 * videos that have been sent to it because they are stored in memory.
 * 
 * @author javiervazquez
 *
 */

@Controller
public class VideoController {

	// An in-memory list that the servlet uses to store the
	// videos that are sent to it by clients
	private List<Video> videos = new CopyOnWriteArrayList<Video>();
	
	private static final AtomicLong currentId = new AtomicLong(0L);
	
    private VideoFileManager videoDataMgr;

	// Receives GET requests to /video and returns the current
	// list of videos in memory. Spring automatically converts
	// the list of videos to JSON because of the @ResponseBody
	// annotation.
	@RequestMapping(value=VideoSvcApi.VIDEO_SVC_PATH, method=RequestMethod.GET)
	public @ResponseBody Collection<Video> getVideoList(){
		return videos;
	}
	
	// Receives POST requests to /video and converts the HTTP
	// request body, which should contain json, into a Video
	// object before adding it to the list. The @RequestBody
	// annotation on the Video parameter is what tells Spring
	// to interpret the HTTP request body as JSON and convert
	// it into a Video object to pass into the method. The
	// @ResponseBody annotation tells Spring to conver the
	// return value from the method back into JSON and put
	// it into the body of the HTTP response to the client.
	//
	// The VIDEO_SVC_PATH is set to "/video" in the VideoSvcApi
	// interface. We use this constant to ensure that the 
	// client and service paths for the VideoSvc are always
	// in synch.
	//
	@RequestMapping(value=VideoSvcApi.VIDEO_SVC_PATH, method=RequestMethod.POST)
	public @ResponseBody Video addVideo(@RequestBody Video v){
		checkAndSetId(v);
		v.setDataUrl(getDataUrl(v.getId()));
		videos.add(v);
		return v;
	}
	
	// Returns the binary mpeg data (if any) for the video with the given
	// identifier. If no mpeg data has been uploaded for the specified video,
	// then the server should return a 404 status code.
	@RequestMapping(value=VideoSvcApi.VIDEO_DATA_PATH, method=RequestMethod.GET)
	public void getVideoData(
			@PathVariable(VideoSvcApi.ID_PARAMETER) final Long id,
			HttpServletResponse response){
		try {
			Video video = (Video) CollectionUtils.find(videos, new org.apache.commons.collections.Predicate() {
		        public boolean evaluate(Object video) {
		            return ((Video)video).getId() == id;
		        }
		    });
			
			if(video != null){
				serveSomeVideo(video, response);
			} else {
				response.setStatus(404);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// The binary mpeg data for the video should be provided in a multipart
	// request as a part with the key "data". The id in the path should be
	// replaced with the unique identifier generated by the server for the
	// Video. A client MUST *create* a Video first by sending a POST to /video
	// and getting the identifier for the newly created Video object before
	// sending a POST to /video/{id}/data. 
	// The endpoint should return a VideoStatus object with state=VideoState.READY
	// if the request succeeds and the appropriate HTTP error status otherwise.
	@RequestMapping(value=VideoSvcApi.VIDEO_DATA_PATH, method=RequestMethod.POST)
	public @ResponseBody VideoStatus setVideoData(
			@PathVariable(VideoSvcApi.ID_PARAMETER) final Long id, 
            @RequestParam(VideoSvcApi.DATA_PARAMETER) MultipartFile videoData,
            HttpServletResponse response) throws NoHandlerFoundException{
		try {
			Video video = (Video) CollectionUtils.find(videos, new org.apache.commons.collections.Predicate() {
		        public boolean evaluate(Object video) {
		            return ((Video)video).getId() == id;
		        }
		    });
			
			if(video != null){
				saveSomeVideo(video, videoData);
			} else {
				response.setStatus(404);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		return new VideoStatus(VideoState.READY);
	}
	
	private String getDataUrl(long videoId){
        String url = getUrlBaseForLocalServer() + VideoSvcApi.VIDEO_SVC_PATH + "/" + videoId + "/" + VideoSvcApi.DATA_PARAMETER;
        return url;
    }

 	private String getUrlBaseForLocalServer() {
	   HttpServletRequest request = 
	       ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
	   String base = 
	      "http://"+request.getServerName() 
	      + ((request.getServerPort() != 80) ? ":"+request.getServerPort() : "");
	   return base;
	}

	private void checkAndSetId(Video video) {
		if(video.getId() == 0){
			video.setId(currentId.incrementAndGet());
		}
	}
	
	public void saveSomeVideo(Video v, MultipartFile videoData) throws IOException {
		videoDataMgr = VideoFileManager.get();
		videoDataMgr.saveVideoData(v, videoData.getInputStream());
	}
			
	public void serveSomeVideo(Video v, HttpServletResponse response) throws IOException {
		videoDataMgr = VideoFileManager.get();
		videoDataMgr.copyVideoData(v, response.getOutputStream());
	}
}
